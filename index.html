<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini Caddie — Saturday MVP (Edit + Course Jump)</title>

  <!-- Leaflet (Map view) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <style>
    :root{
      --bg:#0b0e14;
      --panel:rgba(255,255,255,0.06);
      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;
      --gold:#d1a14b;
      --green:#3fbf7f;
      --red:#cc3b3b;
      --blue:#4aa6ff;
      --radius:18px;
      --shadow: 0 18px 50px rgba(0,0,0,0.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background:
        radial-gradient(1200px 700px at 30% -10%, rgba(74,166,255,0.18), transparent 55%),
        radial-gradient(900px 600px at 100% 0%, rgba(209,161,75,0.16), transparent 55%),
        var(--bg);
      color:var(--ink);
      min-height:100vh;
    }
    .wrap{
      max-width: 1120px;
      margin: 0 auto;
      padding: 12px 12px 24px;
      padding-bottom: calc(24px + env(safe-area-inset-bottom));
    }
    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,14,20,0.92), rgba(11,14,20,0.60));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 10px 10px 12px;
      border-radius: 0 0 18px 18px;
    }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--muted);
      font-size: 13px;
      user-select:none;
      white-space:nowrap;
    }
    .btn{
      border:0; cursor:pointer;
      color: var(--ink);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 850;
      letter-spacing: .2px;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.ghost{
      background: transparent;
      border-color: rgba(255,255,255,0.14);
      color: var(--muted);
    }
    .btn.warn{
      background: linear-gradient(180deg, rgba(74,166,255,0.95), rgba(74,166,255,0.55));
      border-color: rgba(74,166,255,0.35);
      color:#07101b;
      font-weight: 950;
    }
    .btn.primary{
      background: linear-gradient(180deg, rgba(209,161,75,0.95), rgba(209,161,75,0.65));
      border-color: rgba(209,161,75,0.55);
      color:#140f06;
      font-weight: 950;
    }
    .holeCtl{ display:flex; align-items:center; gap:8px; min-width: 260px; }
    .holeNum{ font-size: 18px; font-weight: 950; color: var(--ink); }
    .parTag{
      font-size: 12px;
      font-weight: 900;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(74,166,255,0.16);
      border: 1px solid rgba(74,166,255,0.28);
      color: rgba(232,242,255,0.92);
      white-space:nowrap;
    }

    .controls{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }

    .courseJump{
      display:flex; gap:8px; flex-wrap:wrap;
      align-items:center;
      padding: 8px;
      border-radius: 14px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .courseJump input{
      width: min(520px, 78vw);
      max-width: 520px;
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--ink);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 650;
      outline: none;
    }
    .courseJump input::placeholder{ color: rgba(183,177,162,0.6); }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .card{
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
    }
    .card .hd h2{
      margin:0; font-size: 14px; letter-spacing: .2px;
      color: var(--muted);
      font-weight: 900;
    }
    .card .bd{ padding: 14px; }

    .mapWrap{
      position: relative;
      height: 520px;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    #map{ position:absolute; inset:0; display:none; }
    #diagram{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .legend{
      position:absolute; left:10px; top:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      max-width: calc(100% - 20px);
      z-index: 20;
      pointer-events:none;
    }
    .tag{
      display:inline-flex; align-items:center; gap:7px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
    }
    .dot{ width:8px; height:8px; border-radius:99px; background: var(--muted); }
    .dot.green{ background: var(--green); }
    .dot.gold{ background: var(--gold); }
    .dot.red{ background: var(--red); }
    .dot.blue{ background: var(--blue); }

    .panel{
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.09);
      color: var(--muted);
      font-size: 13px;
      line-height:1.35;
    }
    .panel .title{ font-weight: 950; color: var(--ink); margin-bottom:6px; }
    .divider{ height:1px; background: rgba(255,255,255,0.08); margin: 10px 0; }
    .subline{ margin-top: 10px; color: var(--dim); font-size: 12px; line-height: 1.35; }

    /* Leaflet tooltip label styling */
    .map-label{
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(233,230,220,0.92);
      padding: 2px 7px;
      border-radius: 999px;
      font-weight: 950;
      font-size: 11px;
      letter-spacing: .3px;
    }

    @media (min-width: 1020px){
      .grid{ grid-template-columns: 1.35fr 0.85fr; align-items:start; }
      .mapWrap{ height: 560px; }
    }
  </style>
</head>
<body>

<div class="wrap">
  <div class="topbar">
    <div class="row">
      <div class="holeCtl">
        <button class="btn ghost" id="holePrev" aria-label="Previous hole">◀︎</button>
        <div>
          <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
            <div class="holeNum">Hole <span id="holeNum">1</span></div>
            <div class="parTag" id="parTag">Par 4</div>
            <div class="pill" id="editPill" style="display:none">EDIT ON</div>
          </div>
          <div style="margin-top:2px;color:var(--dim);font-size:12px" id="courseName">Course: Sample Course</div>
        </div>
        <button class="btn ghost" id="holeNext" aria-label="Next hole">▶︎</button>
      </div>

      <div class="controls">
        <!-- Course jump -->
        <div class="courseJump">
          <input id="courseInput" placeholder="Paste Google Maps link OR type a place name (then Go)" />
          <button class="btn" id="courseGoBtn">Go</button>
          <button class="btn primary" id="courseSaveBtn">Save</button>
          <button class="btn ghost" id="courseBtn">Course</button>
        </div>

        <button class="btn" id="viewBtn">View: Diagram</button>
        <button class="btn" id="editBtn">Edit: Off</button>
        <button class="btn" id="targetBtn">Target: Green</button>
        <button class="btn warn" id="closeBtn">Close</button>
        <button class="btn" id="undoBtn">Undo</button>
        <button class="btn" id="clearBtn">Clear</button>

        <button class="btn" id="youBtn">You: Off</button>
        <button class="btn" id="holeBtn">Hole</button>
        <button class="btn" id="centerYouBtn">Center You</button>
        <button class="btn" id="centerPinBtn">Center Pin</button>
        <button class="btn" id="fitBtn">Fit</button>

        <button class="btn" id="exportBtn">Export</button>
        <button class="btn" id="importBtn">Import</button>
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <div class="hd">
        <h2>Hole View</h2>
        <div class="pill" id="modePill">No GPS required — Course Jump + manual YOU</div>
      </div>
      <div class="bd">
        <div class="mapWrap">
          <div id="map"></div>
          <canvas id="diagram"></canvas>

          <div class="legend">
            <div class="tag"><span class="dot blue"></span>You</div>
            <div class="tag"><span class="dot gold"></span>Pin</div>
            <div class="tag"><span class="dot green"></span>Green/Fairway</div>
            <div class="tag"><span class="dot red"></span>Hazard/OB</div>
          </div>
        </div>

        <div class="subline">
          Tip: paste a Google Maps link for your course, hit <b>Go</b>, then <b>Save</b>. After that, <b>Course</b> always jumps there.
        </div>
      </div>
    </div>

    <div class="card">
      <div class="hd">
        <h2>Status</h2>
        <div class="pill" id="holeSummary">—</div>
      </div>
      <div class="bd">
        <div class="panel">
          <div class="title" id="statusTitle">Ready</div>
          <div id="statusText">Use Course Jump to find your course instantly (no GPS).</div>
          <div class="divider"></div>
          <div id="layerCount">—</div>
          <div class="subline" id="anchorLine">Course Anchor: none saved</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const EDIT_KEY = "miniCaddie_courseEdits_v6";
  const UI_KEY   = "miniCaddie_ui_v6";

  const COURSE = {
    id: "sample",
    name: "Sample Course (replace me)",
    holes: Array.from({length:18}).map((_,i)=>({
      n: i+1,
      par: [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,5][i] || 4,
      pin: null,
      you: null,
      green: [], fairway: [], tee: [], bunker: [], water: [], hazard: [], ob: []
    }))
  };

  const TARGETS = [
    { key:"pin",     label:"Pin",     type:"point" },
    { key:"green",   label:"Green",   type:"poly"  },
    { key:"fairway", label:"Fairway", type:"poly"  },
    { key:"tee",     label:"Tee",     type:"poly"  },
    { key:"bunker",  label:"Bunker",  type:"poly"  },
    { key:"water",   label:"Water",   type:"poly"  },
    { key:"hazard",  label:"Hazard",  type:"poly"  },
    { key:"ob",      label:"OB",      type:"poly"  }
  ];

  // DOM
  const $ = (id)=>document.getElementById(id);
  const holeNumEl = $("holeNum");
  const parTagEl = $("parTag");
  const courseNameEl = $("courseName");
  const viewBtn = $("viewBtn");
  const editBtn = $("editBtn");
  const targetBtn = $("targetBtn");
  const closeBtn = $("closeBtn");
  const undoBtn = $("undoBtn");
  const clearBtn = $("clearBtn");
  const youBtn = $("youBtn");
  const holeBtn = $("holeBtn");
  const centerYouBtn = $("centerYouBtn");
  const centerPinBtn = $("centerPinBtn");
  const fitBtn = $("fitBtn");
  const exportBtn = $("exportBtn");
  const importBtn = $("importBtn");
  const editPill = $("editPill");
  const holeSummary = $("holeSummary");
  const statusTitle = $("statusTitle");
  const statusText  = $("statusText");
  const layerCount  = $("layerCount");
  const anchorLine  = $("anchorLine");

  const courseInput = $("courseInput");
  const courseGoBtn = $("courseGoBtn");
  const courseSaveBtn = $("courseSaveBtn");
  const courseBtn = $("courseBtn");

  const mapDiv = $("map");
  const canvas = $("diagram");
  const ctx = canvas.getContext("2d");

  // UI state
  let ui = loadUI();
  let viewMode = ui.viewMode || "diagram";
  let editOn = false;
  let youMode = false;
  let targetKey = "green";
  let draft = [];

  // Edits persistence
  const edits = loadEdits();
  applyEdits();

  // Course anchor (the thing you asked for)
  let anchor = ui.courseAnchor || null; // {lat,lng, label}

  // Leaflet map
  let map = null, mapReady = false, holeLayer = null, draftLayer = null, anchorMarker = null;

  // Canvas projection view
  let view = { minX:0, maxY:1, s:1, pad:24, kx:1 };

  // Init
  courseNameEl.textContent = `Course: ${COURSE.name}`;
  syncView();
  setHole(ui.currentHole ?? 1);

  // ---------------------------
  // NAV
  // ---------------------------
  $("holePrev").addEventListener("click", ()=> setHole(ui.currentHole - 1));
  $("holeNext").addEventListener("click", ()=> setHole(ui.currentHole + 1));

  // ---------------------------
  // VIEW
  // ---------------------------
  viewBtn.addEventListener("click", ()=>{
    viewMode = (viewMode === "diagram") ? "map" : "diagram";
    ui.viewMode = viewMode;
    saveUI();
    syncView();
    redrawAll();
  });

  function syncView(){
    viewBtn.textContent = `View: ${viewMode === "diagram" ? "Diagram" : "Map"}`;
    if(viewMode === "diagram"){
      mapDiv.style.display = "none";
      canvas.style.display = "block";
    }else{
      canvas.style.display = "none";
      mapDiv.style.display = "block";
      ensureMap();
      // key anti-jank: invalidate after visible
      setTimeout(()=>{ if(mapReady){ map.invalidateSize(); } }, 50);
      setTimeout(()=>{ if(mapReady){ map.invalidateSize(); } }, 250);
    }
  }

  // ---------------------------
  // EDIT CONTROLS
  // ---------------------------
  editBtn.addEventListener("click", ()=>{
    editOn = !editOn;
    if(!editOn) draft = [];
    syncHeader();
    redrawAll();
  });

  targetBtn.addEventListener("click", ()=>{
    const i = TARGETS.findIndex(t=>t.key === targetKey);
    targetKey = TARGETS[(i+1) % TARGETS.length].key;
    draft = [];
    syncHeader();
    redrawAll();
  });

  closeBtn.addEventListener("click", ()=>{
    if(!editOn) return;
    const meta = TARGETS.find(t=>t.key === targetKey);
    if(meta.type !== "poly") return;
    if(draft.length < 3){ toast("Need 3+ points to close."); return; }
    const hole = currentHole();
    hole[targetKey].push(draft.map(p=>({lat:p.lat, lng:p.lng})));
    draft = [];
    persistHole();
    toast("Polygon saved.");
    redrawAll();
  });

  undoBtn.addEventListener("click", ()=>{
    const hole = currentHole();
    const meta = TARGETS.find(t=>t.key === targetKey);

    if(editOn && meta.type === "poly" && draft.length){
      draft.pop(); redrawAll(); return;
    }
    if(meta.type === "point"){
      hole.pin = null; persistHole(); toast("Pin cleared."); redrawAll(); return;
    }
    if(Array.isArray(hole[targetKey]) && hole[targetKey].length){
      hole[targetKey].pop(); persistHole(); toast("Last shape removed."); redrawAll();
    }
  });

  clearBtn.addEventListener("click", ()=>{
    if(!editOn){ toast("Turn Edit On to clear."); return; }
    const hole = currentHole();
    const meta = TARGETS.find(t=>t.key === targetKey);

    if(meta.type === "point"){ hole.pin = null; toast("Pin cleared."); }
    else { hole[targetKey] = []; draft = []; toast(`${meta.label} cleared.`); }

    persistHole();
    redrawAll();
  });

  // ---------------------------
  // YOU MARKER
  // ---------------------------
  youBtn.addEventListener("click", ()=>{
    youMode = !youMode;
    youBtn.textContent = `You: ${youMode ? "On" : "Off"}`;
    toast(youMode ? "Tap to place YOU." : "YOU placement off.");
  });

  centerYouBtn.addEventListener("click", ()=>{
    const hole = currentHole();
    if(!hole.you){ toast("No YOU set."); return; }
    if(viewMode === "map"){
      ensureMap();
      map.setView([hole.you.lat, hole.you.lng], Math.max(map.getZoom(), 18));
    }else{
      toast("YOU is the blue marker.");
      redrawDiagram();
    }
  });

  centerPinBtn.addEventListener("click", ()=>{
    const hole = currentHole();
    if(!hole.pin){ toast("No PIN set."); return; }
    if(viewMode === "map"){
      ensureMap();
      map.setView([hole.pin.lat, hole.pin.lng], Math.max(map.getZoom(), 18));
    }else{
      toast("PIN is the gold marker.");
      redrawDiagram();
    }
  });

  // Jump to “hole stuff” quickly
  holeBtn.addEventListener("click", ()=>{
    if(viewMode !== "map"){ toast("Hole jump works best in Map view."); return; }
    ensureMap();
    centerOnHole(true);
  });

  fitBtn.addEventListener("click", ()=>{
    if(viewMode === "map"){ ensureMap(); centerOnHole(true); }
    else { redrawDiagram(); toast("Diagram fit."); }
  });

  // ---------------------------
  // COURSE JUMP (THIS FIXES YOUR ISSUE)
  // ---------------------------
  courseGoBtn.addEventListener("click", async ()=>{
    if(viewMode !== "map"){ viewMode = "map"; ui.viewMode = "map"; saveUI(); syncView(); }
    ensureMap();

    const text = (courseInput.value || "").trim();
    const fromLink = parseLatLngFromText(text);
    if(fromLink){
      setAnchor(fromLink.lat, fromLink.lng, "Course");
      map.setView([fromLink.lat, fromLink.lng], 17);
      toast("Course located from link.");
      return;
    }

    // If they typed an address/name, attempt free geocode (needs internet).
    // If no internet, we tell them to paste a link instead.
    if(!text){
      toast("Paste a Google Maps link or type a place name.");
      return;
    }

    try{
      const ll = await geocodeNominatim(text);
      if(!ll){
        toast("No match. Paste a Google Maps link instead.");
        return;
      }
      setAnchor(ll.lat, ll.lng, ll.label || text);
      map.setView([ll.lat, ll.lng], 17);
      toast("Course located from search.");
    }catch(e){
      toast("Geocode failed (no internet). Paste a Google Maps link.");
    }
  });

  courseSaveBtn.addEventListener("click", ()=>{
    if(!anchor){ toast("No course anchor to save yet. Hit Go first."); return; }
    ui.courseAnchor = anchor;
    saveUI();
    toast("Course anchor saved.");
    updateAnchorLine();
  });

  courseBtn.addEventListener("click", ()=>{
    if(viewMode !== "map"){ viewMode = "map"; ui.viewMode = "map"; saveUI(); syncView(); }
    ensureMap();
    if(!anchor){ toast("No course anchor saved. Use Go then Save."); return; }
    map.setView([anchor.lat, anchor.lng], Math.max(map.getZoom(), 16));
    toast("Jumped to course.");
  });

  function setAnchor(lat, lng, label){
    anchor = { lat, lng, label: label || "Course" };
    updateAnchorLine();
    if(mapReady){
      if(anchorMarker) anchorMarker.remove();
      anchorMarker =
        L.circleMarker([lat,lng], { radius: 9, color:"#0a0d12", weight:3, fillColor:"#ffffff", fillOpacity:0.92 })
         .addTo(map)
         .bindTooltip((anchor.label || "COURSE").toUpperCase(), {permanent:true, direction:"right", className:"map-label", offset:[10,-8]});
    }
  }

  function updateAnchorLine(){
    anchorLine.textContent = anchor
      ? `Course Anchor: ${anchor.label || "Course"} • ${anchor.lat.toFixed(6)}, ${anchor.lng.toFixed(6)}`
      : "Course Anchor: none saved";
  }

  // ---------------------------
  // EXPORT/IMPORT
  // ---------------------------
  exportBtn.addEventListener("click", exportHole);
  importBtn.addEventListener("click", importHole);

  async function exportHole(){
    const hole = currentHole();
    const payload = {
      n: hole.n, par: hole.par,
      you: hole.you, pin: hole.pin,
      green: hole.green, fairway: hole.fairway, tee: hole.tee,
      bunker: hole.bunker, water: hole.water, hazard: hole.hazard, ob: hole.ob
    };
    await copy(JSON.stringify(payload, null, 2));
    toast("Copied hole JSON.");
  }

  function importHole(){
    const raw = prompt("Paste hole JSON (replaces this hole):");
    if(!raw) return;
    let data;
    try{ data = JSON.parse(raw); }catch(e){ alert("Invalid JSON."); return; }

    const hole = currentHole();
    hole.par = data.par ?? hole.par;
    hole.you = data.you ?? null;
    hole.pin = data.pin ?? null;

    hole.green = Array.isArray(data.green) ? data.green : [];
    hole.fairway = Array.isArray(data.fairway) ? data.fairway : [];
    hole.tee = Array.isArray(data.tee) ? data.tee : [];
    hole.bunker = Array.isArray(data.bunker) ? data.bunker : [];
    hole.water = Array.isArray(data.water) ? data.water : [];
    hole.hazard = Array.isArray(data.hazard) ? data.hazard : [];
    hole.ob = Array.isArray(data.ob) ? data.ob : [];

    persistHole();
    draft = [];
    toast("Imported.");
    redrawAll();
    if(viewMode === "map") centerOnHole(true);
  }

  // ---------------------------
  // MAP
  // ---------------------------
  function ensureMap(){
    if(mapReady) return;

    map = L.map("map", { zoomControl:true, attributionControl:false });

    L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      { maxZoom: 21 }
    ).addTo(map);

    holeLayer = L.layerGroup().addTo(map);
    draftLayer = L.layerGroup().addTo(map);

    // start position priority:
    // 1) saved course anchor
    // 2) last view
    // 3) fallback
    if(anchor){
      map.setView([anchor.lat, anchor.lng], 16);
      setAnchor(anchor.lat, anchor.lng, anchor.label || "Course");
    }else if(ui.lastView){
      map.setView([ui.lastView.lat, ui.lastView.lng], ui.lastView.zoom || 16);
    }else{
      map.setView([36.0620, -93.1270], 16);
    }

    map.on("moveend", ()=>{
      const c = map.getCenter();
      ui.lastView = { lat:c.lat, lng:c.lng, zoom: map.getZoom() };
      saveUI();
    });

    map.on("click", (e)=>{
      const ll = { lat: e.latlng.lat, lng: e.latlng.lng };
      handleTap(ll);
    });

    mapReady = true;
    redrawMap();
  }

  function handleTap(ll){
    const hole = currentHole();

    if(youMode){
      hole.you = ll;
      youMode = false;
      youBtn.textContent = "You: Off";
      persistHole();
      redrawAll();
      map.setView([ll.lat, ll.lng], Math.max(map.getZoom(), 18));
      toast("YOU set.");
      return;
    }

    if(!editOn) return;

    const meta = TARGETS.find(t=>t.key === targetKey);
    if(meta.type === "point"){
      hole.pin = ll;
      persistHole();
      redrawAll();
      map.setView([ll.lat, ll.lng], Math.max(map.getZoom(), 18));
      toast("PIN set.");
      return;
    }

    draft.push(ll);
    redrawAll();
  }

  function redrawMap(){
    if(!mapReady) return;
    holeLayer.clearLayers();
    draftLayer.clearLayers();

    const hole = currentHole();

    const styles = {
      green:  { color:"#3fbf7f", weight:2, fillColor:"#3fbf7f", fillOpacity:0.16 },
      fairway:{ color:"#4aa6ff", weight:2, fillColor:"#4aa6ff", fillOpacity:0.10 },
      tee:    { color:"#d1a14b", weight:2, fillColor:"#d1a14b", fillOpacity:0.10 },
      bunker: { color:"#d1a14b", weight:2, fillColor:"#d1a14b", fillOpacity:0.08 },
      water:  { color:"#4aa6ff", weight:2, fillColor:"#4aa6ff", fillOpacity:0.18 },
      hazard: { color:"#cc3b3b", weight:2, fillColor:"#cc3b3b", fillOpacity:0.10 },
      ob:     { color:"#cc3b3b", weight:2, fillColor:"#cc3b3b", fillOpacity:0.06, dashArray:"6 6" }
    };

    drawPolySet(hole.fairway, styles.fairway);
    drawPolySet(hole.tee, styles.tee);
    drawPolySet(hole.green, styles.green);
    drawPolySet(hole.bunker, styles.bunker);
    drawPolySet(hole.water, styles.water);
    drawPolySet(hole.hazard, styles.hazard);
    drawPolySet(hole.ob, styles.ob);

    // Anchor marker (if set)
    if(anchor){
      setAnchor(anchor.lat, anchor.lng, anchor.label || "Course");
    }

    if(hole.pin){
      L.circleMarker([hole.pin.lat, hole.pin.lng], { radius:8, color:"#0a0d12", weight:3, fillColor:"#d1a14b", fillOpacity:0.98 })
        .addTo(holeLayer)
        .bindTooltip("PIN", {permanent:true, direction:"right", className:"map-label", offset:[10,-8]});
    }
    if(hole.you){
      L.circleMarker([hole.you.lat, hole.you.lng], { radius:9, color:"#0a0d12", weight:3, fillColor:"#4aa6ff", fillOpacity:0.98 })
        .addTo(holeLayer)
        .bindTooltip("YOU", {permanent:true, direction:"right", className:"map-label", offset:[10,-8]});
    }

    if(editOn){
      const meta = TARGETS.find(t=>t.key === targetKey);
      if(meta.type === "poly" && draft.length){
        L.polyline(draft.map(p=>[p.lat,p.lng]), { color:"#ffffff", weight:2, opacity:0.9 }).addTo(draftLayer);
        draft.forEach(p=>{
          L.circleMarker([p.lat,p.lng], { radius:4, color:"#0a0d12", weight:2, fillColor:"#ffffff", fillOpacity:0.95 }).addTo(draftLayer);
        });
      }
    }

    function drawPolySet(set, style){
      if(!Array.isArray(set) || !set.length) return;
      set.forEach(poly=>{
        if(Array.isArray(poly) && poly.length >= 3){
          L.polygon(poly.map(p=>[p.lat,p.lng]), style).addTo(holeLayer);
        }
      });
    }
  }

  function centerOnHole(fit){
    if(!mapReady) return;
    const hole = currentHole();
    const pts = collectAllPoints(hole, editOn ? draft : null);

    if(fit && pts.length >= 2){
      const b = L.latLngBounds(pts.map(p=>[p.lat,p.lng]));
      map.fitBounds(b.pad(0.15));
      return;
    }

    const anchorLL =
      hole.you || hole.pin ||
      (hole.green?.[0]?.[0]) || (hole.fairway?.[0]?.[0]) || (hole.tee?.[0]?.[0]) ||
      anchor || (ui.lastView ? {lat:ui.lastView.lat, lng:ui.lastView.lng} : {lat:36.0620, lng:-93.1270});

    map.setView([anchorLL.lat, anchorLL.lng], Math.max(map.getZoom(), 17));
  }

  // ---------------------------
  // DIAGRAM (offline “picture”)
  // ---------------------------
  canvas.addEventListener("click", (e)=>{
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;
    const ll = canvasToLL(cx, cy);
    if(!ll) return;

    // Same tap logic in diagram mode
    const hole = currentHole();
    if(youMode){
      hole.you = ll;
      youMode = false;
      youBtn.textContent = "You: Off";
      persistHole();
      redrawAll();
      toast("YOU set.");
      return;
    }
    if(!editOn) return;

    const meta = TARGETS.find(t=>t.key === targetKey);
    if(meta.type === "point"){
      hole.pin = ll;
      persistHole();
      redrawAll();
      toast("PIN set.");
      return;
    }
    draft.push(ll);
    redrawAll();
  });

  function redrawDiagram(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,rect.width,rect.height);

    // background grid
    ctx.fillStyle = "rgba(255,255,255,0.03)";
    ctx.fillRect(0,0,rect.width,rect.height);
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 1;
    for(let x=24; x<rect.width; x+=28){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rect.height); ctx.stroke(); }
    for(let y=24; y<rect.height; y+=28){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(rect.width,y); ctx.stroke(); }

    const hole = currentHole();
    const pts = collectAllPoints(hole, editOn ? draft : null);

    ctx.fillStyle = "rgba(233,230,220,0.8)";
    ctx.font = "900 13px system-ui";
    ctx.fillText(`Hole ${hole.n} • Par ${hole.par} • Diagram`, 14, 22);

    if(pts.length < 2){
      ctx.fillStyle = "rgba(233,230,220,0.65)";
      ctx.font = "800 14px system-ui";
      ctx.fillText("No shapes yet.", 14, 48);
      ctx.fillStyle = "rgba(183,177,162,0.75)";
      ctx.font = "650 12px system-ui";
      ctx.fillText("Edit: On → draw shapes. You: On → place yourself.", 14, 68);
      view = { minX:0, maxY:1, s:1, pad:24, kx:1 };
      return;
    }

    // Fit bounds using equirectangular local xy
    const meanLat = pts.reduce((s,p)=>s+p.lat,0)/pts.length;
    const kx = Math.cos(meanLat * Math.PI/180) || 1;
    const xy = pts.map(p=>({ x: p.lng * kx, y: p.lat }));

    let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
    xy.forEach(p=>{
      minX=Math.min(minX,p.x); maxX=Math.max(maxX,p.x);
      minY=Math.min(minY,p.y); maxY=Math.max(maxY,p.y);
    });

    const pad = 24;
    const spanX = Math.max(1e-9, maxX-minX);
    const spanY = Math.max(1e-9, maxY-minY);
    const s = Math.min((rect.width-pad*2)/spanX, (rect.height-pad*2)/spanY);
    view = { minX, maxY, s, pad, kx };

    // layers
    drawPolySet(hole.fairway,  "rgba(74,166,255,0.12)", "rgba(74,166,255,0.55)", 2);
    drawPolySet(hole.tee,      "rgba(209,161,75,0.10)", "rgba(209,161,75,0.55)", 2);
    drawPolySet(hole.green,    "rgba(63,191,127,0.18)", "rgba(63,191,127,0.80)", 2.2);
    drawPolySet(hole.bunker,   "rgba(209,161,75,0.08)", "rgba(209,161,75,0.40)", 2);
    drawPolySet(hole.water,    "rgba(74,166,255,0.18)", "rgba(74,166,255,0.55)", 2);
    drawPolySet(hole.hazard,   "rgba(204,59,59,0.12)",  "rgba(204,59,59,0.62)",  2);
    drawPolySet(hole.ob,       "rgba(204,59,59,0.06)",  "rgba(204,59,59,0.70)",  2, [6,6]);

    // draft
    if(editOn && draft.length){
      drawPath(draft, "rgba(255,255,255,0.06)", "rgba(255,255,255,0.92)", 2);
      draft.forEach(p=> dot(p, 4.8, "rgba(255,255,255,0.95)"));
    }

    // markers
    if(hole.pin){ dot(hole.pin, 7, "rgba(209,161,75,0.95)", true, "PIN"); }
    if(hole.you){ dot(hole.you, 7.5, "rgba(74,166,255,0.95)", true, "YOU"); }
    if(anchor){ dot(anchor, 7, "rgba(255,255,255,0.90)", true, "COURSE"); }

    function drawPolySet(set, fill, stroke, w, dash=null){
      if(!Array.isArray(set) || !set.length) return;
      set.forEach(poly=>{
        if(Array.isArray(poly) && poly.length >= 3){
          drawPath(poly, fill, stroke, w, dash, true);
        }
      });
    }
    function drawPath(points, fill, stroke, w, dash=null, closed=false){
      const pts2 = points.map(llToCanvas);
      ctx.save();
      ctx.setLineDash(dash || []);
      ctx.beginPath();
      pts2.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
      if(closed) ctx.closePath();
      if(fill){ ctx.fillStyle = fill; ctx.fill(); }
      ctx.strokeStyle = stroke;
      ctx.lineWidth = w;
      ctx.stroke();
      ctx.restore();
    }
    function dot(ll, r, fill, label=false, text=""){
      const p = llToCanvas(ll);
      ctx.beginPath();
      ctx.arc(p.x,p.y,r,0,Math.PI*2);
      ctx.fillStyle = fill; ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.55)";
      ctx.lineWidth = 3;
      ctx.stroke();
      if(label){
        ctx.fillStyle = "rgba(233,230,220,0.78)";
        ctx.font = "900 12px system-ui";
        ctx.fillText(text, p.x+10, p.y-8);
      }
    }
  }

  function llToCanvas(ll){
    const {minX, maxY, s, pad, kx} = view;
    const x = ll.lng * kx;
    const y = ll.lat;
    return { x: pad + (x - minX) * s, y: pad + (maxY - y) * s };
  }
  function canvasToLL(cx, cy){
    const {minX, maxY, s, pad, kx} = view;
    if(!s || !isFinite(minX) || !isFinite(maxY)) return null;
    const x = (cx - pad)/s + minX;
    const y = maxY - ((cy - pad)/s);
    return { lat: y, lng: x / kx };
  }

  // ---------------------------
  // RENDER COORDINATION
  // ---------------------------
  function redrawAll(){
    syncHeader();
    updateStatus();
    if(viewMode === "map"){ redrawMap(); }
    else { redrawDiagram(); }
  }

  function syncHeader(){
    editBtn.textContent = `Edit: ${editOn ? "On" : "Off"}`;
    const meta = TARGETS.find(t=>t.key === targetKey);
    targetBtn.textContent = `Target: ${meta.label}`;
    editPill.style.display = editOn ? "inline-flex" : "none";
    youBtn.textContent = `You: ${youMode ? "On" : "Off"}`;
    updateAnchorLine();
  }

  function updateStatus(){
    const hole = currentHole();
    holeNumEl.textContent = hole.n;
    parTagEl.textContent = `Par ${hole.par}`;
    holeSummary.textContent = `${hole.pin ? "Pin set" : "No pin"} • ${hole.you ? "You set" : "No you"} • ${anchor ? "Course set" : "No course"}`;

    const meta = TARGETS.find(t=>t.key === targetKey);
    if(youMode) statusText.textContent = "Tap the view to place YOU (blue).";
    else if(editOn) statusText.textContent = meta.type === "point"
      ? "Tap to place PIN (gold)."
      : "Tap points, then Close to save polygon.";
    else statusText.textContent = "Paste Google Maps link → Go → Save. Then Course always jumps there.";

    statusTitle.textContent = viewMode === "map" ? "Map View (Satellite)" : "Diagram View (Offline Picture)";

    const holeCounts =
      `Green:${hole.green.length} • Fairway:${hole.fairway.length} • Tee:${hole.tee.length} • ` +
      `Bunker:${hole.bunker.length} • Water:${hole.water.length} • Hazard:${hole.hazard.length} • OB:${hole.ob.length}`;
    layerCount.textContent = holeCounts + (draft.length ? ` • Draft:${draft.length}` : "");
  }

  function setHole(n){
    if(n < 1) n = 18;
    if(n > 18) n = 1;
    ui.currentHole = n;
    saveUI();
    draft = [];
    youMode = false;
    redrawAll();
  }

  // ---------------------------
  // DATA HELPERS
  // ---------------------------
  function currentHole(){ return COURSE.holes[(ui.currentHole ?? 1) - 1]; }

  function collectAllPoints(hole, extraDraft=null){
    const pts = [];
    if(anchor) pts.push(anchor);
    if(hole.pin) pts.push(hole.pin);
    if(hole.you) pts.push(hole.you);
    ["green","fairway","tee","bunker","water","hazard","ob"].forEach(k=>{
      const set = hole[k];
      if(Array.isArray(set)){
        set.forEach(poly=>{
          if(Array.isArray(poly)) poly.forEach(p=> pts.push(p));
        });
      }
    });
    if(Array.isArray(extraDraft)) extraDraft.forEach(p=> pts.push(p));
    return pts;
  }

  // ---------------------------
  // PERSISTENCE
  // ---------------------------
  function loadUI(){
    try{
      const raw = localStorage.getItem(UI_KEY);
      if(!raw) return { currentHole:1, viewMode:"diagram", lastView:null, courseAnchor:null };
      const s = JSON.parse(raw);
      return {
        currentHole: s.currentHole ?? 1,
        viewMode: s.viewMode ?? "diagram",
        lastView: s.lastView ?? null,
        courseAnchor: s.courseAnchor ?? null
      };
    }catch(e){
      return { currentHole:1, viewMode:"diagram", lastView:null, courseAnchor:null };
    }
  }
  function saveUI(){ localStorage.setItem(UI_KEY, JSON.stringify(ui)); }

  function loadEdits(){
    try{
      const raw = localStorage.getItem(EDIT_KEY);
      if(!raw) return {};
      const d = JSON.parse(raw);
      return (d && typeof d === "object") ? d : {};
    }catch(e){ return {}; }
  }

  function applyEdits(){
    for(const [hn, data] of Object.entries(edits)){
      const idx = Number(hn) - 1;
      const hole = COURSE.holes[idx];
      if(!hole || !data) continue;
      hole.par = data.par ?? hole.par;
      hole.pin = data.pin ?? null;
      hole.you = data.you ?? null;
      hole.green = Array.isArray(data.green) ? data.green : [];
      hole.fairway = Array.isArray(data.fairway) ? data.fairway : [];
      hole.tee = Array.isArray(data.tee) ? data.tee : [];
      hole.bunker = Array.isArray(data.bunker) ? data.bunker : [];
      hole.water = Array.isArray(data.water) ? data.water : [];
      hole.hazard = Array.isArray(data.hazard) ? data.hazard : [];
      hole.ob = Array.isArray(data.ob) ? data.ob : [];
    }
  }

  function persistHole(){
    const hole = currentHole();
    edits[hole.n] = {
      par: hole.par,
      pin: hole.pin || null,
      you: hole.you || null,
      green: hole.green || [],
      fairway: hole.fairway || [],
      tee: hole.tee || [],
      bunker: hole.bunker || [],
      water: hole.water || [],
      hazard: hole.hazard || [],
      ob: hole.ob || []
    };
    localStorage.setItem(EDIT_KEY, JSON.stringify(edits));
  }

  // ---------------------------
  // CLIPBOARD + TOAST
  // ---------------------------
  async function copy(text){
    try{ await navigator.clipboard.writeText(text); }
    catch(e){
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
    }
  }
  function toast(msg){
    statusText.textContent = msg;
    clearTimeout(window.__t);
    window.__t = setTimeout(()=> updateStatus(), 2200);
  }

  // ---------------------------
  // LINK PARSING + GEOCODE
  // ---------------------------
  function parseLatLngFromText(text){
    if(!text) return null;

    // 1) Google "@" format: .../@36.12345,-93.12345,17z
    const at = text.match(/@(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)/);
    if(at) return { lat: Number(at[1]), lng: Number(at[3]) };

    // 2) "q=lat,lng"
    const q = text.match(/[?&]q=(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)/);
    if(q) return { lat: Number(q[1]), lng: Number(q[3]) };

    // 3) plain "lat,lng"
    const plain = text.match(/(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)/);
    if(plain) return { lat: Number(plain[1]), lng: Number(plain[3]) };

    return null;
  }

  async function geocodeNominatim(query){
    // Requires internet. If offline, this will fail and we prompt to paste link instead.
    const url =
      "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" +
      encodeURIComponent(query);

    const res = await fetch(url, {
      headers: { "Accept":"application/json" }
    });
    if(!res.ok) return null;
    const data = await res.json();
    if(!Array.isArray(data) || !data.length) return null;

    return {
      lat: Number(data[0].lat),
      lng: Number(data[0].lon),
      label: data[0].display_name ? data[0].display_name.split(",").slice(0,2).join(",") : query
    };
  }

  // final status
  updateAnchorLine();
  redrawAll();
});
</script>

</body>
</html>
