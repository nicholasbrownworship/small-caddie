<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mini Caddie — No GPS Edit + Offline Hole Images</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg:#0b0e14;
      --panel:rgba(255,255,255,0.06);
      --ink:#e9e6dc;
      --muted:#b7b1a2;
      --dim:#7d776b;
      --gold:#d1a14b;
      --green:#3fbf7f;
      --red:#cc3b3b;
      --blue:#4aa6ff;
      --radius:18px;
      --shadow: 0 18px 50px rgba(0,0,0,0.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
      background: radial-gradient(1200px 700px at 30% -10%, rgba(74,166,255,0.18), transparent 55%),
                  radial-gradient(900px 600px at 100% 0%, rgba(209,161,75,0.16), transparent 55%),
                  var(--bg);
      color:var(--ink);
      min-height:100vh;
    }
    .wrap{
      max-width: 950px;
      margin: 0 auto;
      padding: 12px 12px 24px;
      padding-bottom: calc(24px + env(safe-area-inset-bottom));
    }
    .topbar{
      position: sticky;
      top: 0;
      z-index: 60;
      backdrop-filter: blur(10px);
      background: linear-gradient(to bottom, rgba(11,14,20,0.92), rgba(11,14,20,0.60));
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 10px 10px 12px;
      border-radius: 0 0 18px 18px;
    }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--muted);
      font-size: 13px;
      user-select:none;
      white-space:nowrap;
    }
    .btn{
      border:0; cursor:pointer;
      color: var(--ink);
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 650;
      letter-spacing: .2px;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{
      background: linear-gradient(180deg, rgba(209,161,75,0.95), rgba(209,161,75,0.65));
      border-color: rgba(209,161,75,0.55);
      color: #140f06;
    }
    .btn.warn{
      background: linear-gradient(180deg, rgba(74,166,255,0.95), rgba(74,166,255,0.55));
      border-color: rgba(74,166,255,0.35);
      color:#07101b;
      font-weight: 800;
    }
    .btn.ghost{
      background: transparent;
      border-color: rgba(255,255,255,0.14);
      color: var(--muted);
    }

    .holeCtl{
      display:flex; align-items:center; gap:8px;
      min-width: 260px;
    }
    .holeNum{
      font-size: 18px;
      font-weight: 800;
      color: var(--ink);
    }
    .parTag{
      font-size: 12px;
      font-weight: 750;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(74,166,255,0.16);
      border: 1px solid rgba(74,166,255,0.28);
      color: rgba(232,242,255,0.92);
      white-space:nowrap;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    .card{
      background: var(--panel);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      flex-wrap:wrap;
    }
    .card .hd h2{
      margin:0; font-size: 14px; letter-spacing: .2px;
      color: var(--muted);
      font-weight: 700;
    }
    .card .bd{ padding: 14px; }

    .mapWrap{
      position: relative;
      height: 420px;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
    }
    #map{ position:absolute; inset:0; }
    .mapLegend{
      position:absolute; left:10px; top:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      max-width: calc(100% - 20px);
      z-index: 500;
      pointer-events:none;
    }
    .tag{
      display:inline-flex; align-items:center; gap:7px;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.10);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
    }
    .dot{ width:8px; height:8px; border-radius:99px; background: var(--muted); }
    .dot.green{ background: var(--green); }
    .dot.gold{ background: var(--gold); }
    .dot.red{ background: var(--red); }
    .dot.blue{ background: var(--blue); }

    .subline{ margin-top: 10px; color: var(--dim); font-size: 12px; line-height: 1.35; }

    .twoCol{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    .field{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    input[type="text"]{
      flex: 1;
      min-width: 220px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--ink);
      outline:none;
      font-weight: 650;
    }

    .nudgeBox{
      padding: 12px 14px;
      border-radius: 16px;
      background: rgba(74,166,255,0.10);
      border: 1px solid rgba(74,166,255,0.22);
    }
    .nudgeBox .t{ font-weight: 900; font-size: 14px; color: rgba(232,242,255,0.95); }
    .nudgeBox .d{ margin-top: 4px; color: rgba(232,242,255,0.78); font-size: 13px; }

    .smallBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }

    .leaflet-control-attribution{ display:none; }
    .leaflet-container{ background: #0a0d12; font: inherit; }

    @media (min-width: 950px){
      .grid{ grid-template-columns: 1.25fr 0.9fr; align-items:start; }
      .twoCol{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="row">
        <div class="holeCtl">
          <button class="btn ghost" id="holePrev" aria-label="Previous hole">◀︎</button>
          <div>
            <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
              <div class="holeNum">Hole <span id="holeNum">1</span></div>
              <div class="parTag" id="parTag">Par 4</div>
              <div class="pill" id="editPill" style="display:none">EDIT ON</div>
            </div>
            <div style="margin-top:2px;color:var(--dim);font-size:12px" id="courseName">Course: Sample Course</div>
          </div>
          <button class="btn ghost" id="holeNext" aria-label="Next hole">▶︎</button>
        </div>

        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end">
          <div class="pill" id="modePill">Mode: Manual (no GPS)</div>

          <button class="btn" id="editBtn">Edit: Off</button>
          <button class="btn" id="editTargetBtn">Target: Green</button>
          <button class="btn warn" id="editCloseBtn">Close</button>
          <button class="btn" id="editUndoBtn">Undo</button>
          <button class="btn" id="editClearBtn">Clear</button>

          <button class="btn" id="ballBtn" title="Place your ball marker manually">Ball: Off</button>

          <button class="btn" id="exportBtn">Export</button>
          <button class="btn" id="importBtn">Import</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="hd">
          <h2>Hole Map (Editable, No GPS)</h2>
          <div class="smallBtns">
            <button class="btn ghost" id="centerOnHoleBtn">Center on Hole</button>
            <button class="btn ghost" id="centerOnBallBtn">Center on Ball</button>
          </div>
        </div>
        <div class="bd">
          <div class="twoCol">
            <div class="nudgeBox">
              <div class="t" id="statusTitle">Editing is optional</div>
              <div class="d" id="statusText">
                You can map holes anytime (home or course). Turn Edit On, pick a target, tap points, then Close.
                GPS is not required.
              </div>
            </div>

            <div class="nudgeBox">
              <div class="t">Find the course (optional)</div>
              <div class="d">
                If you have internet, search a place and jump there. If you don’t, use offline hole images.
              </div>
              <div class="field" style="margin-top:10px">
                <input id="searchBox" type="text" placeholder="Search: course name, city, etc." />
                <button class="btn" id="searchBtn">Search</button>
              </div>
              <div class="subline" id="searchHint">
                Offline mode: add hole images in <b>/holes/</b> and set bounds in the HOLE_IMAGES config.
              </div>
            </div>
          </div>

          <div class="mapWrap" style="margin-top:12px">
            <div id="map"></div>
            <div class="mapLegend">
              <div class="tag"><span class="dot blue"></span>Ball (manual)</div>
              <div class="tag"><span class="dot gold"></span>Pin</div>
              <div class="tag"><span class="dot green"></span>Green/Fairway</div>
              <div class="tag"><span class="dot red"></span>Hazard/OB</div>
            </div>
          </div>

          <div class="subline">
            <b>Offline plan:</b> Save a satellite screenshot per hole (or at least your front 9) into <b>/holes/h01.jpg</b>, etc.
            Set each image’s lat/lng bounds in the config, then your hole view works with no signal.
          </div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <h2>Quick Notes</h2>
          <div class="pill" id="holeSummary">—</div>
        </div>
        <div class="bd">
          <div class="nudgeBox">
            <div class="t">On Saturday (no GPS)</div>
            <div class="d">
              You can still use this as a “hole book”: visualize hazards/landing zones, plan lines, and place your ball marker manually.
              If you later enable GPS, we can turn yardages back on.
            </div>
          </div>
          <div class="subline" id="layerCount">—</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   Storage keys
========================= */
const EDIT_KEY  = "miniCaddie_courseEdits_v1";
const UI_KEY    = "miniCaddie_ui_v1";

/* =========================
   Course skeleton
========================= */
const COURSE = {
  id: "sample",
  name: "Sample Course (replace me)",
  holes: Array.from({length:18}).map((_,i)=>({
    n: i+1,
    par: [4,4,3,4,5,4,3,4,5,4,4,3,4,5,4,3,4,5][i] || 4,
    pin: null,
    green: [],
    fairway: [],
    tee: [],
    bunker: [],
    water: [],
    hazard: [],
    ob: [],
    // manual ball marker (per hole, optional)
    ball: null
  }))
};

/* =========================
   OPTIONAL OFFLINE IMAGES (per hole)
   - Put images at: /holes/h01.jpg, /holes/h02.jpg, ...
   - Set bounds: [[northLat, westLng], [southLat, eastLng]]
   - When present, we overlay image on map (works offline if image is local).
========================= */
const HOLE_IMAGES = {
  // Example (replace with your real bounds + image files):
  // 1: { src: "holes/h01.jpg", bounds: [[36.06240, -93.12810], [36.06140, -93.12620]] }
};

/* =========================
   Edit targets
========================= */
const EDIT_TARGETS = [
  { key:"pin",     label:"Pin",     type:"point" },
  { key:"green",   label:"Green",   type:"poly"  },
  { key:"fairway", label:"Fairway", type:"poly"  },
  { key:"tee",     label:"Tee",     type:"poly"  },
  { key:"bunker",  label:"Bunker",  type:"poly"  },
  { key:"water",   label:"Water",   type:"poly"  },
  { key:"hazard",  label:"Hazard",  type:"poly"  },
  { key:"ob",      label:"OB",      type:"poly"  }
];

/* =========================
   App state (no GPS)
========================= */
let state = loadUIState();
let edit = { on:false, target:"green", draft:[] };
let courseEdits = loadCourseEdits();
applyCourseEditsToCourse();

/* =========================
   DOM
========================= */
const el = (id)=>document.getElementById(id);

const holeNumEl = el("holeNum");
const parTagEl = el("parTag");
const courseNameEl = el("courseName");
const modePill = el("modePill");

const editBtn = el("editBtn");
const editTargetBtn = el("editTargetBtn");
const editCloseBtn = el("editCloseBtn");
const editUndoBtn = el("editUndoBtn");
const editClearBtn = el("editClearBtn");
const editPill = el("editPill");

const ballBtn = el("ballBtn");

const exportBtn = el("exportBtn");
const importBtn = el("importBtn");
const centerOnHoleBtn = el("centerOnHoleBtn");
const centerOnBallBtn = el("centerOnBallBtn");

const statusTitle = el("statusTitle");
const statusText = el("statusText");
const holeSummary = el("holeSummary");
const layerCount = el("layerCount");

const searchBox = el("searchBox");
const searchBtn = el("searchBtn");

/* =========================
   Controls
========================= */
el("holePrev").addEventListener("click", ()=> setHole(state.currentHole - 1));
el("holeNext").addEventListener("click", ()=> setHole(state.currentHole + 1));

editBtn.addEventListener("click", ()=>{
  edit.on = !edit.on;
  if(!edit.on) edit.draft = [];
  syncEditUI();
  redrawAll();
});

editTargetBtn.addEventListener("click", ()=>{
  const idx = EDIT_TARGETS.findIndex(t=>t.key === edit.target);
  const next = EDIT_TARGETS[(idx + 1) % EDIT_TARGETS.length];
  edit.target = next.key;
  edit.draft = [];
  syncEditUI();
  redrawAll();
});

editCloseBtn.addEventListener("click", ()=>{
  if(!edit.on) return;
  const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
  if(!meta || meta.type !== "poly") return;
  if(edit.draft.length < 3){
    toast("Need at least 3 points to close a polygon.");
    return;
  }
  const hole = currentHole();
  hole[edit.target] = hole[edit.target] || [];
  hole[edit.target].push(edit.draft.map(p=>({lat:p.lat,lng:p.lng})));
  edit.draft = [];
  persistCurrentHoleEdits();
  redrawAll();
});

editUndoBtn.addEventListener("click", ()=>{
  if(!edit.on) return;
  const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
  const hole = currentHole();

  if(meta?.type === "point"){
    hole.pin = null;
    persistCurrentHoleEdits();
    redrawAll();
    return;
  }

  if(edit.draft.length){
    edit.draft.pop();
    redrawDraft();
    return;
  }

  if(Array.isArray(hole[edit.target]) && hole[edit.target].length){
    hole[edit.target].pop();
    persistCurrentHoleEdits();
    redrawAll();
  }
});

editClearBtn.addEventListener("click", ()=>{
  if(!edit.on) return;
  const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
  const hole = currentHole();

  if(meta?.type === "point"){
    hole.pin = null;
  } else {
    hole[edit.target] = [];
    edit.draft = [];
  }
  persistCurrentHoleEdits();
  redrawAll();
});

ballBtn.addEventListener("click", ()=>{
  const hole = currentHole();
  hole.ballMode = !hole.ballMode;
  ballBtn.textContent = `Ball: ${hole.ballMode ? "On" : "Off"}`;
  toast(hole.ballMode ? "Tap map to place ball marker." : "Ball marker placement off.");
});

exportBtn.addEventListener("click", ()=> exportHoleJSON());
importBtn.addEventListener("click", ()=> importHoleJSON());

centerOnHoleBtn.addEventListener("click", ()=> centerOnHole());
centerOnBallBtn.addEventListener("click", ()=> centerOnBall());

searchBtn.addEventListener("click", ()=> searchPlace());
searchBox.addEventListener("keydown", (e)=>{ if(e.key==="Enter") searchPlace(); });

/* =========================
   Init
========================= */
courseNameEl.textContent = `Course: ${COURSE.name}`;
modePill.textContent = "Mode: Manual (no location services)";
initMap();
setHole(state.currentHole ?? 1);
syncEditUI();
redrawAll();

/* =========================
   State persistence
========================= */
function loadUIState(){
  try{
    const raw = localStorage.getItem(UI_KEY);
    if(raw){
      const s = JSON.parse(raw);
      return {
        currentHole: s.currentHole ?? 1,
        lastView: s.lastView ?? null
      };
    }
  }catch(e){}
  return { currentHole: 1, lastView: null };
}
function saveUIState(){
  localStorage.setItem(UI_KEY, JSON.stringify(state));
}

/* =========================
   Course geometry persistence
========================= */
function loadCourseEdits(){
  try{
    const raw = localStorage.getItem(EDIT_KEY);
    if(!raw) return {};
    const data = JSON.parse(raw);
    return (data && typeof data === "object") ? data : {};
  }catch(e){
    return {};
  }
}
function saveCourseEdits(){
  localStorage.setItem(EDIT_KEY, JSON.stringify(courseEdits));
}
function persistCurrentHoleEdits(){
  const hole = currentHole();
  courseEdits[hole.n] = {
    par: hole.par,
    pin: hole.pin || null,
    green: hole.green || [],
    fairway: hole.fairway || [],
    tee: hole.tee || [],
    bunker: hole.bunker || [],
    water: hole.water || [],
    hazard: hole.hazard || [],
    ob: hole.ob || [],
    ball: hole.ball || null
  };
  saveCourseEdits();
  updateSideInfo();
}
function applyCourseEditsToCourse(){
  for(const [hn, data] of Object.entries(courseEdits)){
    const idx = Number(hn) - 1;
    const hole = COURSE.holes[idx];
    if(!hole || !data) continue;

    hole.pin = data.pin || hole.pin || null;
    hole.green = Array.isArray(data.green) ? data.green : hole.green;
    hole.fairway = Array.isArray(data.fairway) ? data.fairway : hole.fairway;
    hole.tee = Array.isArray(data.tee) ? data.tee : hole.tee;
    hole.bunker = Array.isArray(data.bunker) ? data.bunker : hole.bunker;
    hole.water = Array.isArray(data.water) ? data.water : hole.water;
    hole.hazard = Array.isArray(data.hazard) ? data.hazard : hole.hazard;
    hole.ob = Array.isArray(data.ob) ? data.ob : hole.ob;
    hole.ball = data.ball || hole.ball || null;
  }
}

/* =========================
   Hole helpers
========================= */
function currentHole(){
  return COURSE.holes[state.currentHole - 1];
}
function setHole(n){
  if(n < 1) n = 18;
  if(n > 18) n = 1;
  state.currentHole = n;
  edit.draft = [];
  saveUIState();
  syncEditUI();
  redrawAll();

  // If an offline image is configured, fit to it
  applyOfflineOverlayForHole();
}
function syncEditUI(){
  editBtn.textContent = `Edit: ${edit.on ? "On" : "Off"}`;
  const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
  editTargetBtn.textContent = `Target: ${meta ? meta.label : edit.target}`;
  editPill.style.display = edit.on ? "inline-flex" : "none";

  statusTitle.textContent = edit.on ? "Edit Mode: ON" : "Edit Mode: OFF";
  statusText.textContent = edit.on
    ? "Tap the map to add points. Use Close to save polygons. Target: cycle through pin/green/fairway/tee/bunker/water/hazard/OB."
    : "You can pan/zoom anywhere and map holes from home. Turn Edit On to start placing geometry.";
}

/* =========================
   Map (Leaflet)
========================= */
let map;
let onlineTiles;
let offlineOverlay = null;

let holeGroup;
let draftGroup;
let pinMarker = null;
let ballMarker = null;

function initMap(){
  map = L.map("map", { zoomControl:true, attributionControl:false });

  // Online satellite tiles (works when you have internet; harmless if you don't)
  onlineTiles = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 21 }
  ).addTo(map);

  holeGroup = L.layerGroup().addTo(map);
  draftGroup = L.layerGroup().addTo(map);

  // Restore last view if we have it
  if(state.lastView){
    map.setView([state.lastView.lat, state.lastView.lng], state.lastView.zoom);
  }else{
    // default view (you can change this anytime)
    map.setView([36.0620, -93.1270], 17);
  }

  map.on("moveend", ()=>{
    const c = map.getCenter();
    state.lastView = { lat: c.lat, lng: c.lng, zoom: map.getZoom() };
    saveUIState();
  });

  map.on("click", (e)=>{
    const hole = currentHole();
    const ll = { lat: e.latlng.lat, lng: e.latlng.lng };

    // Ball marker placement
    if(hole.ballMode){
      hole.ball = ll;
      persistCurrentHoleEdits();
      redrawBall();
      return;
    }

    // Edit placement
    if(!edit.on) return;

    const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
    if(meta?.type === "point"){
      hole.pin = ll;
      persistCurrentHoleEdits();
      redrawAll();
      return;
    }

    edit.draft.push(ll);
    redrawDraft();
  });

  applyOfflineOverlayForHole();
}

function applyOfflineOverlayForHole(){
  // Remove any existing overlay
  if(offlineOverlay){
    map.removeLayer(offlineOverlay);
    offlineOverlay = null;
  }

  const hn = currentHole().n;
  const cfg = HOLE_IMAGES[hn];
  if(!cfg || !cfg.src || !cfg.bounds) return;

  offlineOverlay = L.imageOverlay(cfg.src, cfg.bounds, { opacity: 1.0, interactive:false });
  offlineOverlay.addTo(map);

  // Fit map to overlay bounds (so you're looking at the hole immediately)
  try{
    map.fitBounds(cfg.bounds, { padding:[10,10] });
  }catch(e){}
}

function centerOnHole(){
  const hole = currentHole();
  const anchor =
    hole.pin ||
    (hole.green?.[0]?.[0]) ||
    (hole.fairway?.[0]?.[0]) ||
    (hole.tee?.[0]?.[0]) ||
    (hole.ball) ||
    (state.lastView ? {lat: state.lastView.lat, lng: state.lastView.lng} : {lat:36.0620, lng:-93.1270});

  map.setView([anchor.lat, anchor.lng], Math.max(map.getZoom(), 18));
}
function centerOnBall(){
  const hole = currentHole();
  if(!hole.ball) return;
  map.setView([hole.ball.lat, hole.ball.lng], Math.max(map.getZoom(), 18));
}

function redrawAll(){
  holeGroup.clearLayers();
  redrawPolys();
  redrawPin();
  redrawBall();
  redrawDraft();
  updateSideInfo();
}

function redrawPolys(){
  const hole = currentHole();
  drawPolyLayer(hole.fairway, { color:"#4aa6ff", weight:2, fillColor:"#4aa6ff", fillOpacity:0.10 });
  drawPolyLayer(hole.tee,     { color:"#d1a14b", weight:2, fillColor:"#d1a14b", fillOpacity:0.10 });
  drawPolyLayer(hole.green,   { color:"#3fbf7f", weight:2, fillColor:"#3fbf7f", fillOpacity:0.16 });
  drawPolyLayer(hole.bunker,  { color:"#d1a14b", weight:2, fillColor:"#d1a14b", fillOpacity:0.08 });
  drawPolyLayer(hole.water,   { color:"#4aa6ff", weight:2, fillColor:"#4aa6ff", fillOpacity:0.18 });
  drawPolyLayer(hole.hazard,  { color:"#cc3b3b", weight:2, fillColor:"#cc3b3b", fillOpacity:0.10 });
  drawPolyLayer(hole.ob,      { color:"#cc3b3b", weight:2, fillColor:"#cc3b3b", fillOpacity:0.06, dashArray:"6 6" });
}
function drawPolyLayer(layer, style){
  if(!Array.isArray(layer) || layer.length === 0) return;
  layer.forEach(poly=>{
    if(Array.isArray(poly) && poly.length >= 3){
      L.polygon(poly.map(p=>[p.lat,p.lng]), style).addTo(holeGroup);
    }
  });
}

function redrawPin(){
  const hole = currentHole();
  if(pinMarker){
    holeGroup.removeLayer(pinMarker);
    pinMarker = null;
  }
  if(hole.pin){
    pinMarker = L.circleMarker([hole.pin.lat, hole.pin.lng], {
      radius: 7,
      color: "#0a0d12",
      weight: 3,
      fillColor: "#d1a14b",
      fillOpacity: 0.95
    }).addTo(holeGroup);
  }
}

function redrawBall(){
  const hole = currentHole();
  if(ballMarker){
    holeGroup.removeLayer(ballMarker);
    ballMarker = null;
  }
  if(hole.ball){
    ballMarker = L.circleMarker([hole.ball.lat, hole.ball.lng], {
      radius: 7,
      color: "#0a0d12",
      weight: 3,
      fillColor: "#4aa6ff",
      fillOpacity: 0.95
    }).addTo(holeGroup);
  }
}

function redrawDraft(){
  draftGroup.clearLayers();
  if(!edit.on) return;
  const meta = EDIT_TARGETS.find(t=>t.key === edit.target);
  if(!meta || meta.type !== "poly") return;
  if(edit.draft.length === 0) return;

  L.polyline(edit.draft.map(p=>[p.lat,p.lng]), { color:"#ffffff", weight:2, opacity:0.85 }).addTo(draftGroup);
  edit.draft.forEach(p=>{
    L.circleMarker([p.lat,p.lng], { radius:4, color:"#0a0d12", weight:2, fillColor:"#ffffff", fillOpacity:0.9 }).addTo(draftGroup);
  });
}

/* =========================
   Export / Import
========================= */
function exportHoleJSON(){
  const hole = currentHole();
  const data = {
    n: hole.n,
    par: hole.par,
    pin: hole.pin,
    green: hole.green,
    fairway: hole.fairway,
    tee: hole.tee,
    bunker: hole.bunker,
    water: hole.water,
    hazard: hole.hazard,
    ob: hole.ob,
    ball: hole.ball
  };
  const text = JSON.stringify(data, null, 2);
  copyToClipboard(text);
  toast("Hole JSON copied to clipboard.");
}
function importHoleJSON(){
  const raw = prompt("Paste hole JSON (will replace this hole’s shapes):");
  if(!raw) return;

  let data;
  try{ data = JSON.parse(raw); }
  catch(e){ alert("Invalid JSON."); return; }

  const hole = currentHole();
  hole.pin = data.pin || null;
  hole.green = Array.isArray(data.green) ? data.green : [];
  hole.fairway = Array.isArray(data.fairway) ? data.fairway : [];
  hole.tee = Array.isArray(data.tee) ? data.tee : [];
  hole.bunker = Array.isArray(data.bunker) ? data.bunker : [];
  hole.water = Array.isArray(data.water) ? data.water : [];
  hole.hazard = Array.isArray(data.hazard) ? data.hazard : [];
  hole.ob = Array.isArray(data.ob) ? data.ob : [];
  hole.ball = data.ball || null;

  persistCurrentHoleEdits();
  edit.draft = [];
  redrawAll();
  toast("Imported hole geometry.");
}

async function copyToClipboard(text){
  try{
    await navigator.clipboard.writeText(text);
  }catch(e){
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
  }
}

/* =========================
   Search (optional, internet needed)
   Uses OpenStreetMap Nominatim (lightweight).
========================= */
async function searchPlace(){
  const q = (searchBox.value || "").trim();
  if(!q) return;

  toast("Searching…");
  try{
    const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(q)}`;
    const res = await fetch(url, { headers: { "Accept":"application/json" }});
    const data = await res.json();
    if(!Array.isArray(data) || data.length === 0){
      toast("No results.");
      return;
    }
    const hit = data[0];
    const lat = Number(hit.lat), lng = Number(hit.lon);
    map.setView([lat,lng], 18);
    toast("Jumped to search result.");
  }catch(e){
    toast("Search failed (no internet?).");
  }
}

/* =========================
   Side info
========================= */
function updateSideInfo(){
  const hole = currentHole();
  holeNumEl.textContent = hole.n;
  parTagEl.textContent = `Par ${hole.par}`;

  const counts = {
    green: hole.green?.length||0,
    fairway: hole.fairway?.length||0,
    tee: hole.tee?.length||0,
    bunker: hole.bunker?.length||0,
    water: hole.water?.length||0,
    hazard: hole.hazard?.length||0,
    ob: hole.ob?.length||0
  };
  holeSummary.textContent = hole.pin ? "Pin set" : "Pin not set";

  layerCount.textContent =
    `Layers — Green:${counts.green} • Fairway:${counts.fairway} • Tee:${counts.tee} • Bunker:${counts.bunker} • Water:${counts.water} • Hazard:${counts.hazard} • OB:${counts.ob}` +
    (HOLE_IMAGES[hole.n] ? " • Offline image: Yes" : " • Offline image: No");
}

/* =========================
   Tiny toast
========================= */
let toastTimer = null;
function toast(msg){
  statusText.textContent = msg;
  if(toastTimer) clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{ syncEditUI(); }, 2500);
}
</script>
</body>
</html>
